// Package restgen_user provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package restgen_user

import (
	"fmt"
	"net/http"

	"github.com/gin-gonic/gin"
	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

// Defines values for UserTokenPostRequestIcon.
const (
	Fat    UserTokenPostRequestIcon = "fat"
	Heart  UserTokenPostRequestIcon = "heart"
	Oxygen UserTokenPostRequestIcon = "oxygen"
	Sleep  UserTokenPostRequestIcon = "sleep"
	Steps  UserTokenPostRequestIcon = "steps"
)

// Cid Unique file identifier inside IPFS
type Cid = string

// ErrorResponse defines model for ErrorResponse.
type ErrorResponse struct {
	Error *string `json:"error,omitempty"`
}

// UserId User ID inside the blockchain system (address)
type UserId = string

// UserTokenDeleteRequest defines model for UserTokenDeleteRequest.
type UserTokenDeleteRequest struct {
	// Cid Unique file identifier inside IPFS
	Cid Cid `json:"cid"`

	// UserId User ID inside the blockchain system (address)
	UserId UserId `json:"user_id"`
}

// UserTokenListRequest defines model for UserTokenListRequest.
type UserTokenListRequest struct {
	// Cursor Cursor to start from
	Cursor int `json:"cursor"`
	Filter *struct {
		// Name Name of the token
		Name *string `json:"name,omitempty"`
	} `json:"filter,omitempty"`

	// Limit Limit of tokens to return
	Limit int `json:"limit"`

	// UserId User ID inside the blockchain system (address)
	UserId UserId `json:"user_id"`
}

// UserTokenPatchRequest defines model for UserTokenPatchRequest.
type UserTokenPatchRequest struct {
	// Cid Unique file identifier inside IPFS
	Cid Cid `json:"cid"`

	// File File to be tokenized
	File *openapi_types.File `json:"file,omitempty"`

	// Name Token name
	Name *string `json:"name,omitempty"`
}

// UserTokenPostRequest defines model for UserTokenPostRequest.
type UserTokenPostRequest struct {
	// File File to be tokenized
	File openapi_types.File       `json:"file"`
	Icon UserTokenPostRequestIcon `json:"icon"`

	// Name Token name
	Name string `json:"name"`

	// Signature Signature of the user
	Signature string `json:"signature"`
}

// UserTokenPostRequestIcon defines model for UserTokenPostRequest.Icon.
type UserTokenPostRequestIcon string

// GetUserTokenParams defines parameters for GetUserToken.
type GetUserTokenParams struct {
	TokenName string `form:"token_name" json:"token_name"`
	Signature string `form:"signature" json:"signature"`
}

// DeleteUserTokenJSONRequestBody defines body for DeleteUserToken for application/json ContentType.
type DeleteUserTokenJSONRequestBody = UserTokenDeleteRequest

// PatchUserTokenJSONRequestBody defines body for PatchUserToken for application/json ContentType.
type PatchUserTokenJSONRequestBody = UserTokenPatchRequest

// PostUserTokenMultipartRequestBody defines body for PostUserToken for multipart/form-data ContentType.
type PostUserTokenMultipartRequestBody = UserTokenPostRequest

// GetUserTokenListJSONRequestBody defines body for GetUserTokenList for application/json ContentType.
type GetUserTokenListJSONRequestBody = UserTokenListRequest

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (DELETE /user/token)
	DeleteUserToken(c *gin.Context)

	// (GET /user/token)
	GetUserToken(c *gin.Context, params GetUserTokenParams)

	// (PATCH /user/token)
	PatchUserToken(c *gin.Context)

	// (POST /user/token)
	PostUserToken(c *gin.Context)

	// (GET /user/token/list)
	GetUserTokenList(c *gin.Context)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandler       func(*gin.Context, error, int)
}

type MiddlewareFunc func(c *gin.Context)

// DeleteUserToken operation middleware
func (siw *ServerInterfaceWrapper) DeleteUserToken(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.DeleteUserToken(c)
}

// GetUserToken operation middleware
func (siw *ServerInterfaceWrapper) GetUserToken(c *gin.Context) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetUserTokenParams

	// ------------- Required query parameter "token_name" -------------

	if paramValue := c.Query("token_name"); paramValue != "" {

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Query argument token_name is required, but not found"), http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "token_name", c.Request.URL.Query(), &params.TokenName)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter token_name: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Required query parameter "signature" -------------

	if paramValue := c.Query("signature"); paramValue != "" {

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Query argument signature is required, but not found"), http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "signature", c.Request.URL.Query(), &params.Signature)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter signature: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetUserToken(c, params)
}

// PatchUserToken operation middleware
func (siw *ServerInterfaceWrapper) PatchUserToken(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.PatchUserToken(c)
}

// PostUserToken operation middleware
func (siw *ServerInterfaceWrapper) PostUserToken(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.PostUserToken(c)
}

// GetUserTokenList operation middleware
func (siw *ServerInterfaceWrapper) GetUserTokenList(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetUserTokenList(c)
}

// GinServerOptions provides options for the Gin server.
type GinServerOptions struct {
	BaseURL      string
	Middlewares  []MiddlewareFunc
	ErrorHandler func(*gin.Context, error, int)
}

// RegisterHandlers creates http.Handler with routing matching OpenAPI spec.
func RegisterHandlers(router gin.IRouter, si ServerInterface) {
	RegisterHandlersWithOptions(router, si, GinServerOptions{})
}

// RegisterHandlersWithOptions creates http.Handler with additional options
func RegisterHandlersWithOptions(router gin.IRouter, si ServerInterface, options GinServerOptions) {
	errorHandler := options.ErrorHandler
	if errorHandler == nil {
		errorHandler = func(c *gin.Context, err error, statusCode int) {
			c.JSON(statusCode, gin.H{"msg": err.Error()})
		}
	}

	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandler:       errorHandler,
	}

	router.DELETE(options.BaseURL+"/user/token", wrapper.DeleteUserToken)
	router.GET(options.BaseURL+"/user/token", wrapper.GetUserToken)
	router.PATCH(options.BaseURL+"/user/token", wrapper.PatchUserToken)
	router.POST(options.BaseURL+"/user/token", wrapper.PostUserToken)
	router.GET(options.BaseURL+"/user/token/list", wrapper.GetUserTokenList)
}
