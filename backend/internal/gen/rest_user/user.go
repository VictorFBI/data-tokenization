// Package rest_user provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package rest_user

import (
	"fmt"
	"net/http"

	externalRef0 "data-tokenization/internal/gen/rest_common"

	"github.com/gin-gonic/gin"
	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

// File File to be tokenized
type File = openapi_types.File

// TokenListItems defines model for TokenListItems.
type TokenListItems struct {
	CurrencyCode string `json:"currency_code"`

	// Name Name of the user's tokenized file
	Name externalRef0.TokenName `json:"name"`

	// Price Число с точностью до 18 знаков после запятой
	Price externalRef0.Price `json:"price"`
	Type  string             `json:"type"`
}

// UserDeleteTokenRequest defines model for UserDeleteTokenRequest.
type UserDeleteTokenRequest struct {
	// Name Name of the user's tokenized file
	Name externalRef0.TokenName `json:"name"`

	// UserId User ID inside the blockchain system (address)
	UserId externalRef0.UserId `json:"user_id"`
}

// UserGetTokenDownloadLinkResponse defines model for UserGetTokenDownloadLinkResponse.
type UserGetTokenDownloadLinkResponse struct {
	Link string `json:"link"`
}

// UserGetTokenResponse defines model for UserGetTokenResponse.
type UserGetTokenResponse struct {
	Token *externalRef0.Token `json:"token,omitempty"`
}

// UserHistoryItem defines model for UserHistoryItem.
type UserHistoryItem struct {
	Action string            `json:"action"`
	Date   externalRef0.Date `json:"date"`

	// TokenName Name of the user's tokenized file
	TokenName externalRef0.TokenName `json:"token_name"`
}

// UserHistoryTokenResponse defines model for UserHistoryTokenResponse.
type UserHistoryTokenResponse struct {
	// NextCursor Limit of tokens_repository to return
	NextCursor *externalRef0.Cursor `json:"next_cursor,omitempty"`
	Tokens     *[]UserHistoryItem   `json:"tokens,omitempty"`
}

// UserListTokenResponse defines model for UserListTokenResponse.
type UserListTokenResponse struct {
	// NextCursor Limit of tokens_repository to return
	NextCursor *externalRef0.Cursor `json:"next_cursor,omitempty"`
	Tokens     *[]TokenListItems    `json:"tokens,omitempty"`
}

// UserPatchTokenRequest defines model for UserPatchTokenRequest.
type UserPatchTokenRequest struct {
	CurrencyCode *string `json:"currency_code,omitempty"`
	Description  *string `json:"description,omitempty"`
	IsOnMarket   *bool   `json:"is_on_market,omitempty"`

	// Name Name of the user's tokenized file
	Name    externalRef0.TokenName `json:"name"`
	NewName *string                `json:"new_name,omitempty"`

	// Price Число с точностью до 18 знаков после запятой
	Price *externalRef0.Price `json:"price,omitempty"`
	Type  *string             `json:"type,omitempty"`

	// UserId User ID inside the blockchain system (address)
	UserId externalRef0.UserId `json:"user_id"`
}

// UserPostTokenRequest defines model for UserPostTokenRequest.
type UserPostTokenRequest struct {
	CurrencyCode string `json:"currency_code"`

	// File File to be tokenized
	File File `json:"file"`

	// Name Name of the user's tokenized file
	Name externalRef0.TokenName `json:"name"`

	// Price Число с точностью до 18 знаков после запятой
	Price externalRef0.Price `json:"price"`
	Type  string             `json:"type"`

	// UserId User ID inside the blockchain system (address)
	UserId externalRef0.UserId `json:"user_id"`
}

// GetUserHistoryParams defines parameters for GetUserHistory.
type GetUserHistoryParams struct {
	UserId externalRef0.UserId `form:"user_id" json:"user_id"`
	Cursor externalRef0.Cursor `form:"cursor" json:"cursor"`
	Limit  externalRef0.Limit  `form:"limit" json:"limit"`
}

// GetUserTokenParams defines parameters for GetUserToken.
type GetUserTokenParams struct {
	UserId externalRef0.UserId    `form:"user_id" json:"user_id"`
	Name   externalRef0.TokenName `form:"name" json:"name"`
}

// GetUserTokenDownloadLinkParams defines parameters for GetUserTokenDownloadLink.
type GetUserTokenDownloadLinkParams struct {
	UserId externalRef0.UserId    `form:"user_id" json:"user_id"`
	Name   externalRef0.TokenName `form:"name" json:"name"`
}

// GetUserTokenListParams defines parameters for GetUserTokenList.
type GetUserTokenListParams struct {
	UserId                   externalRef0.UserId         `form:"user_id" json:"user_id"`
	Cursor                   externalRef0.Cursor         `form:"cursor" json:"cursor"`
	Limit                    externalRef0.Limit          `form:"limit" json:"limit"`
	Name                     *externalRef0.TokenName     `form:"name,omitempty" json:"name,omitempty"`
	Type                     *string                     `form:"type,omitempty" json:"type,omitempty"`
	StartDate                *externalRef0.Date          `form:"start_date,omitempty" json:"start_date,omitempty"`
	EndDate                  *externalRef0.Date          `form:"end_date,omitempty" json:"end_date,omitempty"`
	SortDirectionOnUpdatedAt *externalRef0.SortDirection `form:"sort_direction_on_updated_at,omitempty" json:"sort_direction_on_updated_at,omitempty"`
}

// DeleteUserTokenJSONRequestBody defines body for DeleteUserToken for application/json ContentType.
type DeleteUserTokenJSONRequestBody = UserDeleteTokenRequest

// PatchUserTokenJSONRequestBody defines body for PatchUserToken for application/json ContentType.
type PatchUserTokenJSONRequestBody = UserPatchTokenRequest

// PostUserTokenMultipartRequestBody defines body for PostUserToken for multipart/form-data ContentType.
type PostUserTokenMultipartRequestBody = UserPostTokenRequest

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (GET /user/history)
	GetUserHistory(c *gin.Context, params GetUserHistoryParams)

	// (DELETE /user/token)
	DeleteUserToken(c *gin.Context)

	// (GET /user/token)
	GetUserToken(c *gin.Context, params GetUserTokenParams)

	// (PATCH /user/token)
	PatchUserToken(c *gin.Context)

	// (POST /user/token)
	PostUserToken(c *gin.Context)

	// (GET /user/token/downloadLink)
	GetUserTokenDownloadLink(c *gin.Context, params GetUserTokenDownloadLinkParams)

	// (GET /user/token/list)
	GetUserTokenList(c *gin.Context, params GetUserTokenListParams)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandler       func(*gin.Context, error, int)
}

type MiddlewareFunc func(c *gin.Context)

// GetUserHistory operation middleware
func (siw *ServerInterfaceWrapper) GetUserHistory(c *gin.Context) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetUserHistoryParams

	// ------------- Required query parameter "user_id" -------------

	if paramValue := c.Query("user_id"); paramValue != "" {

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Query argument user_id is required, but not found"), http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "user_id", c.Request.URL.Query(), &params.UserId)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter user_id: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Required query parameter "cursor" -------------

	if paramValue := c.Query("cursor"); paramValue != "" {

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Query argument cursor is required, but not found"), http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "cursor", c.Request.URL.Query(), &params.Cursor)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter cursor: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Required query parameter "limit" -------------

	if paramValue := c.Query("limit"); paramValue != "" {

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Query argument limit is required, but not found"), http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "limit", c.Request.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter limit: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetUserHistory(c, params)
}

// DeleteUserToken operation middleware
func (siw *ServerInterfaceWrapper) DeleteUserToken(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.DeleteUserToken(c)
}

// GetUserToken operation middleware
func (siw *ServerInterfaceWrapper) GetUserToken(c *gin.Context) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetUserTokenParams

	// ------------- Required query parameter "user_id" -------------

	if paramValue := c.Query("user_id"); paramValue != "" {

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Query argument user_id is required, but not found"), http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "user_id", c.Request.URL.Query(), &params.UserId)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter user_id: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Required query parameter "name" -------------

	if paramValue := c.Query("name"); paramValue != "" {

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Query argument name is required, but not found"), http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "name", c.Request.URL.Query(), &params.Name)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter name: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetUserToken(c, params)
}

// PatchUserToken operation middleware
func (siw *ServerInterfaceWrapper) PatchUserToken(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.PatchUserToken(c)
}

// PostUserToken operation middleware
func (siw *ServerInterfaceWrapper) PostUserToken(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.PostUserToken(c)
}

// GetUserTokenDownloadLink operation middleware
func (siw *ServerInterfaceWrapper) GetUserTokenDownloadLink(c *gin.Context) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetUserTokenDownloadLinkParams

	// ------------- Required query parameter "user_id" -------------

	if paramValue := c.Query("user_id"); paramValue != "" {

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Query argument user_id is required, but not found"), http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "user_id", c.Request.URL.Query(), &params.UserId)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter user_id: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Required query parameter "name" -------------

	if paramValue := c.Query("name"); paramValue != "" {

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Query argument name is required, but not found"), http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "name", c.Request.URL.Query(), &params.Name)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter name: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetUserTokenDownloadLink(c, params)
}

// GetUserTokenList operation middleware
func (siw *ServerInterfaceWrapper) GetUserTokenList(c *gin.Context) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetUserTokenListParams

	// ------------- Required query parameter "user_id" -------------

	if paramValue := c.Query("user_id"); paramValue != "" {

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Query argument user_id is required, but not found"), http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "user_id", c.Request.URL.Query(), &params.UserId)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter user_id: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Required query parameter "cursor" -------------

	if paramValue := c.Query("cursor"); paramValue != "" {

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Query argument cursor is required, but not found"), http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "cursor", c.Request.URL.Query(), &params.Cursor)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter cursor: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Required query parameter "limit" -------------

	if paramValue := c.Query("limit"); paramValue != "" {

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Query argument limit is required, but not found"), http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "limit", c.Request.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter limit: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, false, "name", c.Request.URL.Query(), &params.Name)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter name: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", c.Request.URL.Query(), &params.Type)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter type: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "start_date" -------------

	err = runtime.BindQueryParameter("form", true, false, "start_date", c.Request.URL.Query(), &params.StartDate)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter start_date: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "end_date" -------------

	err = runtime.BindQueryParameter("form", true, false, "end_date", c.Request.URL.Query(), &params.EndDate)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter end_date: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "sort_direction_on_updated_at" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort_direction_on_updated_at", c.Request.URL.Query(), &params.SortDirectionOnUpdatedAt)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter sort_direction_on_updated_at: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetUserTokenList(c, params)
}

// GinServerOptions provides options for the Gin server.
type GinServerOptions struct {
	BaseURL      string
	Middlewares  []MiddlewareFunc
	ErrorHandler func(*gin.Context, error, int)
}

// RegisterHandlers creates http.Handler with routing matching OpenAPI spec.
func RegisterHandlers(router gin.IRouter, si ServerInterface) {
	RegisterHandlersWithOptions(router, si, GinServerOptions{})
}

// RegisterHandlersWithOptions creates http.Handler with additional options
func RegisterHandlersWithOptions(router gin.IRouter, si ServerInterface, options GinServerOptions) {
	errorHandler := options.ErrorHandler
	if errorHandler == nil {
		errorHandler = func(c *gin.Context, err error, statusCode int) {
			c.JSON(statusCode, gin.H{"msg": err.Error()})
		}
	}

	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandler:       errorHandler,
	}

	router.GET(options.BaseURL+"/user/history", wrapper.GetUserHistory)
	router.DELETE(options.BaseURL+"/user/token", wrapper.DeleteUserToken)
	router.GET(options.BaseURL+"/user/token", wrapper.GetUserToken)
	router.PATCH(options.BaseURL+"/user/token", wrapper.PatchUserToken)
	router.POST(options.BaseURL+"/user/token", wrapper.PostUserToken)
	router.GET(options.BaseURL+"/user/token/downloadLink", wrapper.GetUserTokenDownloadLink)
	router.GET(options.BaseURL+"/user/token/list", wrapper.GetUserTokenList)
}
