// Package rest_market provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package rest_market

import (
	"fmt"
	"net/http"

	externalRef0 "data-tokenization/internal/gen/rest_common"

	"github.com/gin-gonic/gin"
	"github.com/oapi-codegen/runtime"
)

// MarketTokenBuyRequest defines model for MarketTokenBuyRequest.
type MarketTokenBuyRequest struct {
	// BuyerId User ID inside the blockchain system (address)
	BuyerId externalRef0.UserId `json:"buyer_id"`

	// SellerId User ID inside the blockchain system (address)
	SellerId externalRef0.UserId `json:"seller_id"`

	// TokenName Name of the user's tokenized file
	TokenName externalRef0.TokenName `json:"token_name"`
}

// MarketTokenBuyResponse defines model for MarketTokenBuyResponse.
type MarketTokenBuyResponse struct {
	Message string `json:"message"`
}

// MarketTokenGetResponse defines model for MarketTokenGetResponse.
type MarketTokenGetResponse struct {
	Token externalRef0.Token `json:"token"`
}

// MarketTokenListResponse defines model for MarketTokenListResponse.
type MarketTokenListResponse struct {
	NextCursor *int                              `json:"next_cursor,omitempty"`
	Tokens     *[]externalRef0.ListTokenResponse `json:"tokens,omitempty"`
}

// GetMarketTokenParams defines parameters for GetMarketToken.
type GetMarketTokenParams struct {
	UserId    externalRef0.UserId    `form:"user_id" json:"user_id"`
	TokenName externalRef0.TokenName `form:"token_name" json:"token_name"`
}

// GetMarketTokenListParams defines parameters for GetMarketTokenList.
type GetMarketTokenListParams struct {
	Cursor                   externalRef0.Cursor         `form:"cursor" json:"cursor"`
	Limit                    externalRef0.Limit          `form:"limit" json:"limit"`
	UserId                   externalRef0.UserId         `form:"user_id" json:"user_id"`
	Name                     *externalRef0.TokenName     `form:"name,omitempty" json:"name,omitempty"`
	Type                     *string                     `form:"type,omitempty" json:"type,omitempty"`
	StartDate                *externalRef0.Date          `form:"start_date,omitempty" json:"start_date,omitempty"`
	EndDate                  *externalRef0.Date          `form:"end_date,omitempty" json:"end_date,omitempty"`
	SortDirectionOnUpdatedAt *externalRef0.SortDirection `form:"sort_direction_on_updated_at,omitempty" json:"sort_direction_on_updated_at,omitempty"`
	IsOnMarket               *bool                       `form:"is_on_market,omitempty" json:"is_on_market,omitempty"`
}

// PostMarketTokenBuyJSONRequestBody defines body for PostMarketTokenBuy for application/json ContentType.
type PostMarketTokenBuyJSONRequestBody = MarketTokenBuyRequest

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (GET /market/token)
	GetMarketToken(c *gin.Context, params GetMarketTokenParams)

	// (POST /market/token/buy)
	PostMarketTokenBuy(c *gin.Context)

	// (GET /market/token/list)
	GetMarketTokenList(c *gin.Context, params GetMarketTokenListParams)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandler       func(*gin.Context, error, int)
}

type MiddlewareFunc func(c *gin.Context)

// GetMarketToken operation middleware
func (siw *ServerInterfaceWrapper) GetMarketToken(c *gin.Context) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetMarketTokenParams

	// ------------- Required query parameter "user_id" -------------

	if paramValue := c.Query("user_id"); paramValue != "" {

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Query argument user_id is required, but not found"), http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "user_id", c.Request.URL.Query(), &params.UserId)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter user_id: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Required query parameter "token_name" -------------

	if paramValue := c.Query("token_name"); paramValue != "" {

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Query argument token_name is required, but not found"), http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "token_name", c.Request.URL.Query(), &params.TokenName)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter token_name: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetMarketToken(c, params)
}

// PostMarketTokenBuy operation middleware
func (siw *ServerInterfaceWrapper) PostMarketTokenBuy(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.PostMarketTokenBuy(c)
}

// GetMarketTokenList operation middleware
func (siw *ServerInterfaceWrapper) GetMarketTokenList(c *gin.Context) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetMarketTokenListParams

	// ------------- Required query parameter "cursor" -------------

	if paramValue := c.Query("cursor"); paramValue != "" {

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Query argument cursor is required, but not found"), http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "cursor", c.Request.URL.Query(), &params.Cursor)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter cursor: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Required query parameter "limit" -------------

	if paramValue := c.Query("limit"); paramValue != "" {

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Query argument limit is required, but not found"), http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "limit", c.Request.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter limit: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Required query parameter "user_id" -------------

	if paramValue := c.Query("user_id"); paramValue != "" {

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Query argument user_id is required, but not found"), http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "user_id", c.Request.URL.Query(), &params.UserId)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter user_id: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, false, "name", c.Request.URL.Query(), &params.Name)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter name: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", c.Request.URL.Query(), &params.Type)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter type: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "start_date" -------------

	err = runtime.BindQueryParameter("form", true, false, "start_date", c.Request.URL.Query(), &params.StartDate)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter start_date: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "end_date" -------------

	err = runtime.BindQueryParameter("form", true, false, "end_date", c.Request.URL.Query(), &params.EndDate)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter end_date: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "sort_direction_on_updated_at" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort_direction_on_updated_at", c.Request.URL.Query(), &params.SortDirectionOnUpdatedAt)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter sort_direction_on_updated_at: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "is_on_market" -------------

	err = runtime.BindQueryParameter("form", true, false, "is_on_market", c.Request.URL.Query(), &params.IsOnMarket)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter is_on_market: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetMarketTokenList(c, params)
}

// GinServerOptions provides options for the Gin server.
type GinServerOptions struct {
	BaseURL      string
	Middlewares  []MiddlewareFunc
	ErrorHandler func(*gin.Context, error, int)
}

// RegisterHandlers creates http.Handler with routing matching OpenAPI spec.
func RegisterHandlers(router gin.IRouter, si ServerInterface) {
	RegisterHandlersWithOptions(router, si, GinServerOptions{})
}

// RegisterHandlersWithOptions creates http.Handler with additional options
func RegisterHandlersWithOptions(router gin.IRouter, si ServerInterface, options GinServerOptions) {
	errorHandler := options.ErrorHandler
	if errorHandler == nil {
		errorHandler = func(c *gin.Context, err error, statusCode int) {
			c.JSON(statusCode, gin.H{"msg": err.Error()})
		}
	}

	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandler:       errorHandler,
	}

	router.GET(options.BaseURL+"/market/token", wrapper.GetMarketToken)
	router.POST(options.BaseURL+"/market/token/buy", wrapper.PostMarketTokenBuy)
	router.GET(options.BaseURL+"/market/token/list", wrapper.GetMarketTokenList)
}
